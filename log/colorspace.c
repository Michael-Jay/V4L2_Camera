
YUV是通过亮度-色差来描述颜色的颜色空间。

YUV主要用于优化彩色视频信号的传输，使其向后相容老式黑白电视。与RGB视频信号传输相比，它最大的优点在于只需占用极少的频宽（RGB要求三个独立的视频信号同时传输）。“亮度”是透过RGB输入信号来建立的，方法是将RGB信号的特定部分叠加到一起。“色度”则定义了颜色的两个方面─色调与饱和度，分别用Cr和Cb来表示。其中，Cr反映了RGB输入信号红色部分与RGB信号亮度值之间的差异。而Cb反映的是RGB输入信号蓝色部分与RGB信号亮度值之间的差异。
采用YUV色彩空间的重要性是它的亮度信号Y和色度信号U、V是分离的。如果只有Y信号分量而没有U、V分量，那么这样表示的图像就是黑白灰度图像。彩色电视采用YUV空间正是为了用亮度信号Y解决彩色电视机与黑白电视机的兼容问题，使黑白电视机也能接收彩色电视信号。

Today, the term YUV is commonly used in the computer industry to describe file-formats that are encoded using YCbCr.

"与R GB视频信号传输相比，它最大的优点在于只需占用极少的带宽（RGB要求三个独立的视频信号同时传输）"
"Y表示明亮度（Luminance或Luma），也就是灰阶值；基带信号"
"而“U”和“V” 表示的则是色度(Chrominance或Chroma), 作用是描述影像色彩及饱和度，用于指定像素的颜色。非基带信号,被正交调制过的.

    "亮度"是通过RGB输入信号来创建的，方法是将RGB信号的特定部分叠加到一起。
    "色度"则定义了颜色的两个方面-色调与饱和度，分别用Cr和CB来表示。
    	Cr反映RGB输入信号red与RGB信号亮度值Y之间的差异。
    	Cb反映RGB输入信号blue与RGB信号亮度值Y之同的差异。
    	"通过运算，YUV三分量可以还原出R（红），G（绿），B（兰）。

    	上边仅给出了理论上的示例，在实际数据存储中是有可能是不同的，下面给出几种具体的存储形式：
		（1） YUV 4:4:4
		YUV三个信道的"Y:U:V抽样率"相同"4:4:4""
		因此在生成的图像里，每个象素的"三个分量信息完整(每个分量通常8比特)"
		经过8比特量化之后，"未经压缩的每个像素占用3个字节。"
		下面的四个像素为:   [Y0 U0 V0] [Y1 U1 V1] [Y2 U2 V2] [Y3 U3 V3]
		存放的码流为: 	  Y0 U0 V0   Y1 U1 V1   Y2 U2 V2   Y3 U3 V3
		（2） YUV 4:2:2(YUYV)
		"每个色差信道的抽样率是亮度信道的一半,Y:U:V抽样率 = 4:2:2"。
		对非压缩的8比特量化的图像来说，每个由两个水平方向相邻的像素组成的宏像素需要占用4字节内存。
		下面的四个像素为[Y0 U0 V0] [Y1 U1 V1] [Y2 U2 V2] [Y3 U3 V3]
		存放的码流为：	  Y0 U0(YU) Y1 V1(YV)  Y2 U2(YU)  Y3 V3(YV)
		映射出像素点为：[Y0 U0 V1] [Y1 U0 V1] [Y2 U2 V3] [Y3 U2 V3]


YUV格式通常有两大类："打包（packed）格式"和"平面（planar）格式"。
"packed"将YUV分量存放在同一个数组中，通常是几个相邻的像素组成一个宏像素（macro-pixel）；
"planar"使用三个数组分开存放YUV三个分量，就像是一个三维平面一样。


"YUV2RGB快速算法分析
        R = Y + 1.4075 *（V-128）
        G = Y – 0.3455 *（U –128） – 0.7169 *（V –128）
        B = Y + 1.779 *（U – 128）
   1 整型算法

       要用整型运算代替浮点运算，当然是要用移位的办法了，我们可以很容易得到下列算法：

        u = YUVdata[UPOS] - 128;
        v = YUVdata[VPOS] - 128;

        rdif = v + ((v * 103) >> 8);
        invgdif = ((u * 88) >> 8) +((v * 183) >> 8);
        bdif = u +( (u*198) >> 8);

        r = YUVdata[YPOS] + rdif;
        g = YUVdata[YPOS] - invgdif;
        b = YUVdata[YPOS] + bdif;

	为了防止出现溢出，还需要判错计算的结果是否在0-255范围内，做类似下面的判断。

        if (r>255)
            r=255;
        if (r<0)
            r=0;

        要从RGB24转换成RGB565数据还要做移位和或运算：

        RGBdata[1] =( (r & 0xF8)  | ( g >> 5) );
        RGBdata[0] =( ((g & 0x1C) << 3) | ( b >> 3) );
